diff --git a/bot_impl/actions.js b/bot_impl/actions.js
index 43e6966..9b58f78 100644
--- a/bot_impl/actions.js
+++ b/bot_impl/actions.js
@@ -58,7 +58,7 @@ function install (bot, { log, on, registerCleanup }) {
     try { m.allow1by1towers = false } catch {}
     try { m.allowParkour = false } catch {}
     try { m.allowParkourPlace = false } catch {}
-    try { m.scafoldingBlocks = [] } catch {}
+    try { m.scafodingBlocks = [] } catch {}
     try { m.scaffoldingBlocks = [] } catch {}
     bot.pathfinder.setMovements(m)
 
@@ -321,11 +321,7 @@ function install (bot, { log, on, registerCleanup }) {
     const m = new Movements(bot, mcData)
     m.canDig = true
     m.allowSprinting = true
-    try { m.allow1by1towers = false } catch {}
-    try { m.allowParkour = false } catch {}
-    try { m.allowParkourPlace = false } catch {}
-    try { m.scafoldingBlocks = [] } catch {}
-    try { m.scaffoldingBlocks = [] } catch {}
+    // Allow default parkour/tower/scaffolding behavior
     bot.pathfinder.setMovements(m)
 
     function now () { return Date.now() }
diff --git a/bot_impl/agent/runner.js b/bot_impl/agent/runner.js
index 4894465..2ccb333 100644
--- a/bot_impl/agent/runner.js
+++ b/bot_impl/agent/runner.js
@@ -28,6 +28,7 @@ function install (bot, { on, registerCleanup, log }) {
     const id = makeId()
     const task = { id, name, args, expected, status: 'running', progress: 0, createdAt: Date.now(), events: [], controller: ctl, lastTickAt: 0 }
     S.tasks.set(id, task)
+    info('start', name, 'id=', id)
     // allow skill to run any immediate init
     try { if (typeof ctl.start === 'function') ctl.start() } catch (e) { warn('start err', e?.message || e) }
     return { ok: true, msg: '已开始', taskId: id }
@@ -118,7 +119,7 @@ function install (bot, { on, registerCleanup, log }) {
         if (res && res.status && res.status !== 'running') {
           task.status = res.status
           task.progress = Number.isFinite(res.progress) ? res.progress : (res.status === 'succeeded' ? 1 : task.progress)
-          if (res.status !== 'running') S.tasks.delete(task.id)
+          if (res.status !== 'running') { S.tasks.delete(task.id); info('end', task.name, 'id=', task.id, 'status=', res.status) }
         } else {
           task.progress = Number.isFinite(res.progress) ? res.progress : task.progress
         }
@@ -127,6 +128,7 @@ function install (bot, { on, registerCleanup, log }) {
         task.status = 'failed'
         pushEvents(task, [{ type: 'error', error: String(e?.message || e) }])
         S.tasks.delete(task.id)
+        info('end', task.name, 'id=', task.id, 'status=failed')
       }
     }
   }
diff --git a/bot_impl/index.js b/bot_impl/index.js
index d599b4b..a60e2a9 100644
--- a/bot_impl/index.js
+++ b/bot_impl/index.js
@@ -343,8 +343,15 @@ function activate (botInstance, options = {}) {
       state.currentTask = { name: String(info?.tool || info?.name || 'unknown'), source, startedAt: Date.now() }
     } catch {}
   })
-  on('external:end', () => {
-    try { state.currentTask = null } catch {}
+  on('external:end', (info) => {
+    try {
+      const endTool = String(info?.tool || '').toLowerCase()
+      const cur = state.currentTask && String(state.currentTask.name || '').toLowerCase()
+      // Only clear if names match or no current task; avoid clearing tasks started by another module (e.g., skills)
+      if (!cur || !endTool || cur === endTool) {
+        state.currentTask = null
+      }
+    } catch {}
   })
 
   function registerCleanup (fn) {
diff --git a/bot_impl/skills/mine-ore.js b/bot_impl/skills/mine-ore.js
index 1b31b76..837a315 100644
--- a/bot_impl/skills/mine-ore.js
+++ b/bot_impl/skills/mine-ore.js
@@ -121,10 +121,7 @@ module.exports = function mineOreFactory ({ bot, args, log }) {
       const m = new Movements(bot, mc)
       m.canDig = !!allowDig
       m.allowSprinting = true
-      try { m.allow1by1towers = false } catch {}
-      try { m.allowParkour = false } catch {}
-      try { m.allowParkourPlace = false } catch {}
-      try { m.scafoldingBlocks = [] } catch {}
+      // Allow default parkour/tower/scaffolding behavior
       bot.pathfinder.setMovements(m)
       // Approach near the block (do not target occupying the ore's cell)
       bot.pathfinder.setGoal(new goals.GoalNear(block.position.x, block.position.y, block.position.z, 2), true)
@@ -279,10 +276,7 @@ module.exports = function mineOreFactory ({ bot, args, log }) {
     const m = new Movements(bot, mc)
     m.canDig = !!allowDig
     m.allowSprinting = true
-    try { m.allow1by1towers = false } catch {}
-    try { m.allowParkour = false } catch {}
-    try { m.allowParkourPlace = false } catch {}
-    try { m.scafoldingBlocks = [] } catch {}
+    // Allow default parkour/tower/scaffolding behavior
     bot.pathfinder.setMovements(m)
     const goal = new goals.GoalNear(Math.floor(pos.x), Math.floor(pos.y), Math.floor(pos.z), Math.max(1, Math.floor(range)))
     try { await bot.pathfinder.goto(goal) } catch {}
@@ -384,10 +378,7 @@ module.exports = function mineOreFactory ({ bot, args, log }) {
     const m = new Movements(bot, mcd)
     m.canDig = true
     m.allowSprinting = true
-    try { m.allow1by1towers = false } catch {}
-    try { m.allowParkour = false } catch {}
-    try { m.allowParkourPlace = false } catch {}
-    try { m.scafoldingBlocks = [] } catch {}
+    // Allow default parkour/tower/scaffolding behavior
     bot.pathfinder.setMovements(m)
     const g = new goals.GoalNear(Math.floor(pos.x), Math.floor(pos.y), Math.floor(pos.z), 1)
     bot.pathfinder.setGoal(g)
@@ -404,10 +395,7 @@ module.exports = function mineOreFactory ({ bot, args, log }) {
       const m = new Movements(bot, mcd)
       m.canDig = true
       m.allowSprinting = true
-      try { m.allow1by1towers = false } catch {}
-      try { m.allowParkour = false } catch {}
-      try { m.allowParkourPlace = false } catch {}
-      try { m.scafoldingBlocks = [] } catch {}
+      // Allow default parkour/tower/scaffolding behavior
       bot.pathfinder.setMovements(m)
       const angle = Math.random() * Math.PI * 2
       const dx = Math.round(Math.cos(angle) * step)
